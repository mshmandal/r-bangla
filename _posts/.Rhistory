library(torch)
torch_tensor(1, device = "cuda")
data<- cars
data(cars)
lab <- "Hosaka Sensei"
LabName <- "Lab of Ecology and Ecosystem"
print(LabName)
LabHead <- "Hosaka Sensei"
OurLab <- LabName, LabHead
OurLab <- c(LabName, LabHead)
print(Ourlab)
print(Ourlab)
print(OurLab)
OurLab[1]
OurLab[2]
OurLab2 <- c("Lab of Ecology and Ecosystem","Hosaka Sensei" )
print(OurLab2)
OurLab2 <- c("Lab of Ecology and Ecosystem","Hosaka Sensei", "Hiroshima University" )
print(OurLab2)
OurLab2 <- c("Lab of Ecology and Ecosystem","Hosaka Sensei", "Hiroshima University", 1 )
print(OurLab2)
OurLab2 <- c("Lab of Ecology and Ecosystem","Hosaka Sensei", "Hiroshima University", +81546
6565)
OurLab2 <- c("Lab of Ecology and Ecosystem","Hosaka Sensei", "Hiroshima University", +815466565, "420")
x <- 2
y < "2"
x +1
y <- "2"
x +1
y+1
data("airquality")
head(airquality)
head(airquality)[10,10]
head(airquality)[,10]
head(airquality)[,1]
head(airquality)[10,]
head(airquality)[1,]
dim(airquality)
head(airquality)[15,]
head(airquality)
?head(airquality)
head(iris3)
head(iris3, c(6L, 2L))
head(iris3, c(6L, -1L, 2L)))
head(iris3, c(6L, -1L, 2L)))
head(iris3)
head(iris3, c(6L, 2L))
iris3[10,]
dim(iris3)
data("cars")
cars[10,]
cars[10,]
cars[1:10,]
cars[10:20,]
parallel::stopCluster(cl)
parallel::stopCluster()
parallel::getDefaultCluster()
parallel::detectCores()
library(rnaturalearth)
map <- ne_countries(scale = "50", returnclass = sf)
map <- ne_countries(scale = "50", returnclass = "sf")
map <- ne_countries(scale = "50", returnclass = "sf")
map <- ne_countries(scale = 50, returnclass = "sf")
ggplot(map)+
geom_sf()
library(ggplot2)
ggplot(map)+
geom_sf()
c = st_read(system.file("shape/nc.shp", package="sf"))
# load data from the package
data(World)
library(tmap)
# load data from the package
data(World)
tm_shape(World)+
tm_polygons(col = 'lightblue')
tm_shape(World)+
tm_polygons(col = 'lightblue')
tm_shape(World)+
tm_polygons(col = 'lightblue')
st_crs(World)
library(sf)
st_crs(World)
w84 <- st_transform(World, 4326)
tm_shape(w84)
tm_shape(w84)+tm_polygons()
tm_shape(World)+
tm_polygons()
tm_shape(w84)+tm_polygons(col = 'lighblue')
tm_shape(w84)+tm_polygons(col = 'lighblue')
w84 <- st_transform(World, 4326)
tm_shape(w84)+tm_polygons(col = 'lighblue')
tm_shape(w84)+tm_polygons(col = 'lightblue')
tm_shape(w84)+tm_polygons(col = 'grey')
tm_shape(World)+tm_polygons()
tm_shape(w84)+tm_polygons(col = 'grey')
tm_shape(w84)+tm_polygons(col = 'lightgreen')
w.wgs84 <- st_transform(World, 4326) # to WGS84
w.moll <- st_transform(World, 54009) # to Mollweide projection
w.wgs84 <- st_transform(World, 4326) # to WGS84
w.moll <- st_transform(World, 54009) # to Mollweide projection
w.moll <- st_transform(World, crs = "+proj=moll") # to Mollweide projection
tm_shape(w.moll)+tm_polygons(col = 'lightgreen')
w.moll <- lwgeom::st_transform_proj(World, crs = "+proj=wintri") # to Mollweide projection
w.moll <- st_transform(World, crs = "+proj=moll")                  # to Mollweide projection
w.wintri <- lwgeom::st_transform_proj(World, crs = "+proj=wintri") # to Wintri projection
tm_shape(w84)+tm_polygons(col = 'lightgreen')
tm_shape(w.moll)+tm_polygons(col = 'lightgreen')
tm_shape(w.wintri)+tm_polygons(col = 'lightgreen')
tm_shape(World)+tm_polygons()
tm_shape(World)+tm_polygons(col = 'lightgreen')
# Change crs
st_crs(World)  # check crs
w.wgs84 <- st_transform(World, 4326) # to WGS84
w.moll <- st_transform(World, crs = "+proj=moll")                  # to Mollweide projection
w.wintri <- lwgeom::st_transform_proj(World, crs = "+proj=wintri") # to Wintri projection
tm_shape(w84)+tm_polygons(col = 'lightgreen')
tm_shape(w.moll)+tm_polygons(col = 'lightgreen')
tm_shape(w.wintri)+tm_polygons(col = 'lightgreen')
tm_shape(w84)+tm_polygons(col = 'grey')
tm_shape(w84)+tm_polygons(col = 'grey')
tm_shape(w.moll)+tm_polygons(col = 'grey')
tm_shape(w.wintri)+tm_polygons(col = 'grey')
# Play with colors
tm_shape(w.wintri)+
tm_polygons(col = 'MAP_COLORS')
w.wintri
str(w.wintri)
tm_shape(w.wintri)+
tm_polygons(col = 'economy') #
tm_shape(w.wintri)+
tm_polygons(col = 'economy', style=F) #
tm_shape(w.wintri)+
tm_polygons(col = 'economy', style='cat') #
tm_shape(w.wintri)+
tm_polygons(col = 'economy', style='num') #
tm_shape(w.wintri)+
tm_polygons(col = 'economy', style='cat') #
# Make categorical maps
str(w.wintri)
tm_shape(w.wintri)+
tm_polygons(col = 'economy', style='cat') # if categorical
tm_shape(w.wintri)+
tm_polygons(col = 'income_gap', style='cat') # if categorical
# Make categorical maps
str(w.wintri)
tm_shape(w.wintri)+
tm_polygons(col = 'income_grp', style='cat') # if categorical
# Discrete maps
tm_shape(w.wintri)+
tm_polygons(col = 'HPI', style='cat') # if categorical
# Discrete maps
tm_shape(w.wintri)+
tm_polygons(col = 'HPI', style='pretty') # if categorical
# Discrete maps
tm_shape(w.wintri)+
tm_polygons(col = 'HPI', style='pretty',
legend.hist = TRUE) # if categorical
# Discrete maps
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='pretty',
legend.hist = TRUE) +
tm_layout(legend.outside = TRUE)
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='pretty',
legend.hist = TRUE,
n=4) +
tm_layout(legend.outside = TRUE)
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='pretty',
legend.hist = TRUE,
n=10) +
tm_layout(legend.outside = TRUE)
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='pretty',
legend.hist = TRUE,
n=5) +
tm_layout(legend.outside = TRUE)
# Fixed style can be used for manual selection of breaks
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='fixed',
legend.hist = TRUE,
breaks=c(15,30,45)) +
tm_layout(legend.outside = TRUE)
# Fixed style can be used for manual selection of breaks
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='fixed',
legend.hist = TRUE,
breaks=c(0,15,30,45)) +
tm_layout(legend.outside = TRUE)
# Fixed style can be used for manual selection of breaks
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='fixed',
legend.hist = TRUE,
breaks=c(0,15,30,45),
labels=c('Low','Medium',"High","NA")) +
tm_layout(legend.outside = TRUE)
# Fixed style can be used for manual selection of breaks
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='fixed',
legend.hist = TRUE,
breaks=c(0,15,30,45),
labels=c('Low','Medium',"High")) +
tm_layout(legend.outside = TRUE)
# Continuous maps
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='count',
legend.hist = TRUE,
breaks=c(0,15,30,45),
labels=c('Low','Medium',"High")) +
tm_layout(legend.outside = TRUE)
# Continuous maps
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='cont',
legend.hist = TRUE,
breaks=c(0,15,30,45),
labels=c('Low','Medium',"High")) +
tm_layout(legend.outside = TRUE)
# Continuous maps
tm_shape(w.wintri)+
tm_polygons(col = 'HPI',
style='cont') +
tm_layout(legend.outside = TRUE)
# Make categorical maps
str(w.wintri)
# Continuous maps
tm_shape(w.wintri)+
tm_polygons(col = 'pop_est',
style='cont') +
tm_layout(legend.outside = TRUE)
# Continuous maps
tm_shape(w.wintri)+
tm_polygons(col = 'pop_est') +
tm_layout(legend.outside = TRUE)
# Continuous maps
tm_shape(w.wintri)+
tm_polygons(col = 'pop_est', style = "pretty") +
tm_layout(legend.outside = TRUE)
### Use logarithmic scales
tm_shape(w.wintri)+
tm_polygons(col = 'pop_est', style = "log10_pretty") +
tm_layout(legend.outside = TRUE)
data(cars)
str(cars)
summary(cars)
cars$dist[cars$dist > 50]
summary(cars)
cars[cars$dist > 50]
df <-cars
df[df$dist > 50]
summary(df)
df <- subset(cars, dist  > 50)
summary(df)
#!/usr/bin/env Rscript
options(stringsAsFactors = FALSE)
KnitPost <- function(bashwd = "", convert_file = "", overwrite = FALSE) {
# CONVERT ALL RMD FILES TO MARKDOWN?
#    REQUIRED: overwrite
# CONVERT A SPECIFIC RMD FILE TO MARKDOWN?
#    REQUIRED: bashwd, convert_file
# bashwd: working directory (passed on from bash, only used below
#         if a specific Rmd file is to be converted)
# convert_file: name/path to specific Rmd file to convert
# overwrite: flag that tells us whether to overwrite md files
#            when converting all Rmd files
# directory of jekyll blog (including trailing slash)
site.path <- "C:/myweb/blog/"
getwd()
# directory where your Rmd-files reside (relative to base)
rmd.path <- paste0(site.path, "_knitr")
# directory to save figures
fig.dir <- "figures/"
# directory for converted markdown files
posts.path <- paste0(site.path, "_posts")
# cache
cache.path <- paste0(site.path, "_cache")
require(knitr)
render_jekyll(highlight = "pygments")
# "base.dir is never used when composing the URL of the figures; it is
# only used to save the figures to a different directory, which can
# be useful when you do not want the figures to be saved under the
# current working directory.
# The URL of an image is always base.url + fig.path"
# https://groups.google.com/forum/#!topic/knitr/18aXpOmsumQ
opts_knit$set(
base.url = "/",
base.dir = site.path)
opts_chunk$set(
fig.path   = fig.dir,
fig.width  = 8.5,
fig.height = 5.25,
dev        = 'svg',
cache      = FALSE,
warning    = FALSE,
message    = FALSE,
cache.path = cache.path,
tidy       = FALSE)
if (convert_file == "") {
# convert all Rmd files in {site-url}/_knitr/ to markdown files
# contingent on whether overwrite requested and if md exists
# setwd to Rmd folder
setwd(rmd.path)
files.rmd <-
data.frame(rmd = list.files(
path = rmd.path,
full.names = TRUE,
pattern = "\\.Rmd$",
ignore.case = TRUE,
recursive = FALSE))
files.rmd$corresponding.md.file <-
paste0(posts.path, "/",
basename(gsub(pattern = "\\.Rmd$",
replacement = ".md",
x = files.rmd$rmd)))
files.rmd$corresponding.md.exists <-
file.exists(files.rmd$corresponding.md.file)
files.rmd$md.overwrite <- overwrite
files.rmd$md.render <- FALSE
# check if corresponding md file exists for each Rmd file,
# if not, set flag to convert to markdown
# (also consider the overwrite flag set by user)
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$corresponding.md.exists[i] == FALSE) {
files.rmd$md.render[i] <- TRUE
}
if ((files.rmd$corresponding.md.exists[i] == TRUE) &&
(files.rmd$md.overwrite[i] == TRUE)) {
files.rmd$md.render[i] <- TRUE
}
}
# For each Rmd file, render markdown (contingent on the flags set above)
for (i in 1:dim(files.rmd)[1]) {
# only re-knit if overwrite==TRUE or .md not already existing
if (files.rmd$md.render[i] == TRUE) {
# KNITTING ====
message(paste0("=== KnitPost(overwrite=", overwrite, "): ",
basename(files.rmd$rmd[i])))
out.file <-
knit(files.rmd$rmd[i],
output = files.rmd$corresponding.md.file[i],
envir = parent.frame(),
quiet = TRUE)
}
}
} else {
# convert a single Rmd file to markdown
# setwd to bash pwd
setwd(bashwd)
convert.path <- paste0(bashwd, "/", convert_file)
md.path <-
paste0(posts.path, "/",
basename(gsub(pattern = "\\.Rmd$",
replacement = ".md",
x = convert_file)))
# KNITTING ====
message(paste0("=== KnitPost(", convert.path, ")"))
out.file <-
knit(convert.path,
output = md.path,
envir = parent.frame(),
quiet = TRUE)
}
}
#!/usr/bin/env Rscript
options(stringsAsFactors = FALSE)
KnitPost <- function(bashwd = "", convert_file = "", overwrite = FALSE) {
# CONVERT ALL RMD FILES TO MARKDOWN?
#    REQUIRED: overwrite
# CONVERT A SPECIFIC RMD FILE TO MARKDOWN?
#    REQUIRED: bashwd, convert_file
# bashwd: working directory (passed on from bash, only used below
#         if a specific Rmd file is to be converted)
# convert_file: name/path to specific Rmd file to convert
# overwrite: flag that tells us whether to overwrite md files
#            when converting all Rmd files
# directory of jekyll blog (including trailing slash)
site.path <- "C:/myweb/blog/"
getwd()
# directory where your Rmd-files reside (relative to base)
rmd.path <- paste0(site.path, "_knitr")
# directory to save figures
fig.dir <- "figures/"
# directory for converted markdown files
posts.path <- paste0(site.path, "_posts")
# cache
cache.path <- paste0(site.path, "_cache")
require(knitr)
render_jekyll(highlight = "pygments")
# "base.dir is never used when composing the URL of the figures; it is
# only used to save the figures to a different directory, which can
# be useful when you do not want the figures to be saved under the
# current working directory.
# The URL of an image is always base.url + fig.path"
# https://groups.google.com/forum/#!topic/knitr/18aXpOmsumQ
opts_knit$set(
base.url = "/",
base.dir = site.path)
opts_chunk$set(
fig.path   = fig.dir,
fig.width  = 8.5,
fig.height = 5.25,
dev        = 'svg',
cache      = FALSE,
warning    = FALSE,
message    = FALSE,
cache.path = cache.path,
tidy       = FALSE)
if (convert_file == "") {
# convert all Rmd files in {site-url}/_knitr/ to markdown files
# contingent on whether overwrite requested and if md exists
# setwd to Rmd folder
setwd(rmd.path)
files.rmd <-
data.frame(rmd = list.files(
path = rmd.path,
full.names = TRUE,
pattern = "\\.Rmd$",
ignore.case = TRUE,
recursive = FALSE))
files.rmd$corresponding.md.file <-
paste0(posts.path, "/",
basename(gsub(pattern = "\\.Rmd$",
replacement = ".md",
x = files.rmd$rmd)))
files.rmd$corresponding.md.exists <-
file.exists(files.rmd$corresponding.md.file)
files.rmd$md.overwrite <- overwrite
files.rmd$md.render <- FALSE
# check if corresponding md file exists for each Rmd file,
# if not, set flag to convert to markdown
# (also consider the overwrite flag set by user)
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$corresponding.md.exists[i] == FALSE) {
files.rmd$md.render[i] <- TRUE
}
if ((files.rmd$corresponding.md.exists[i] == TRUE) &&
(files.rmd$md.overwrite[i] == TRUE)) {
files.rmd$md.render[i] <- TRUE
}
}
# For each Rmd file, render markdown (contingent on the flags set above)
for (i in 1:dim(files.rmd)[1]) {
# only re-knit if overwrite==TRUE or .md not already existing
if (files.rmd$md.render[i] == TRUE) {
# KNITTING ====
message(paste0("=== KnitPost(overwrite=", overwrite, "): ",
basename(files.rmd$rmd[i])))
out.file <-
knit(files.rmd$rmd[i],
output = files.rmd$corresponding.md.file[i],
envir = parent.frame(),
quiet = TRUE)
}
}
} else {
# convert a single Rmd file to markdown
# setwd to bash pwd
setwd(bashwd)
convert.path <- paste0(bashwd, "/", convert_file)
md.path <-
paste0(posts.path, "/",
basename(gsub(pattern = "\\.Rmd$",
replacement = ".md",
x = convert_file)))
# KNITTING ====
message(paste0("=== KnitPost(", convert.path, ")"))
out.file <-
knit(convert.path,
output = md.path,
envir = parent.frame(),
quiet = TRUE)
}
}
getwd()
setwd("C:\mycourse\r-bengali\docs\_source")
```{r}
# নিচের কোডটি রান করতে হলে Cntrl + Enter চাপুন, একই ভাবে পরবর্তী কোড গুলি রান করতে হবে।
# লাইনের শুরুতে হ্যাশটি তুলে দিয়ে রান করতে হবে। শুধু প্রথমবার।
# install.packages('tmap', dependencies = T)  # প্যাকেজ ইন্সটল,
# প্যাকেজটি লোড করুন
library(tmap)
```
tmap প্যাকেজে একটি ডেটা লোড করা থাকে, এটি পুরো পৃথিবীর জিআইএস লেয়ার ডেটা।
সেটি লোড করে R এ ম্যাপটি প্রদর্শনের জন্য নিচের কোডটি রান করুন
```{r}
# নিচের কোডটি রান করতে হলে Cntrl + Enter চাপুন, একই ভাবে পরবর্তী কোড গুলি রান করতে হবে।
# লাইনের শুরুতে হ্যাশটি তুলে দিয়ে রান করতে হবে। শুধু প্রথমবার।
# install.packages('tmap', dependencies = T)  # প্যাকেজ ইন্সটল,
# প্যাকেজটি লোড করুন
library(tmap)
```
tmap প্যাকেজে একটি ডেটা লোড করা থাকে, এটি পুরো পৃথিবীর জিআইএস লেয়ার ডেটা।
সেটি লোড করে R এ ম্যাপটি প্রদর্শনের জন্য নিচের কোডটি রান করুন
knitr::opts_chunk$set(echo = TRUE)
data(World)                      # ডেটা লোডিং
# কোন ডেটা প্রদর্শন করতে চাই
# ডেটাটি পলিগন আকারের দেখানোর জন্য, এবং ম্যাপে একটি টাইটেল প্রদর্শন
tm_shape(World)+
tm_polygons("HPI", main='My first Map')
library(knitr)
getwd()
setwd("C:\\mycourse\\r-bangla\\_posts")
